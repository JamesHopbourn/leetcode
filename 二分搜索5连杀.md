#### 704. 二分查找

**解题思路**：在有序数组中查找目标值，使用二分查找算法。关键是确定搜索区间和循环条件。

**方法一：左闭右闭区间 [left, right]**
```java
class Solution {
    public int search(int[] nums, int target) {
        // 定义左闭右闭区间 [left, right]
        int left = 0;
        int right = nums.length - 1; // 右边界包含在搜索范围内
        
        // 当 left == right 时，区间 [left, right] 仍然有效
        while (left <= right) {
            // 防止整数溢出的写法
            int mid = left + (right - left) / 2;
            
            if (nums[mid] == target) {
                return mid; // 找到目标值，返回索引
            } else if (nums[mid] < target) {
                left = mid + 1; // 目标值在右半部分，缩小左边界
            } else if (nums[mid] > target) {
                right = mid - 1; // 目标值在左半部分，缩小右边界
            }
        }
        return -1; // 未找到目标值
    }
}
```

**方法二：左闭右开区间 [left, right)**
```java
class Solution {
    public int search(int[] nums, int target) {
        // 定义左闭右开区间 [left, right)
        int left = 0;
        int right = nums.length; // 右边界不包含在搜索范围内
        
        // 当 left == right 时，区间 [left, right) 无效
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1; // 目标值在右半部分
            } else if (nums[mid] > target) {
                right = mid; // 目标值在左半部分，right不包含在区间内
            }
        }
        return -1;
    }
}
```

#### 27. 移除元素

**解题思路**：使用双指针（快慢指针）技巧，快指针遍历数组，慢指针维护不等于val的元素位置。

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        // 慢指针：指向下一个不等于val的元素应该存放的位置
        int slow = 0;
        // 快指针：用于遍历数组
        int fast = 0;
        
        while (fast < nums.length) {
            // 如果快指针指向的元素不等于val，则保留该元素
            if (nums[fast] != val) {
                nums[slow] = nums[fast]; // 将有效元素移动到慢指针位置
                slow++; // 慢指针向前移动
            }
            fast++; // 快指针继续遍历
        }
        
        // 返回新数组的长度（即不等于val的元素个数）
        return slow;
    }
}
```

#### 977. 有序数组的平方

**解题思路**：数组已按非递减顺序排序，但平方后可能不是有序的（因为负数）。使用双指针从两端向中间遍历，比较两端元素的平方值，将较大值放入结果数组的末尾。

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        // 左指针指向数组开始，右指针指向数组结尾
        int left = 0;
        int right = nums.length - 1;
        // 结果数组的填充位置，从后往前填充
        int index = nums.length - 1;

        int[] result = new int[nums.length];
        
        // 双指针相向而行
        while (left <= right) {
            // 比较两端元素的平方值
            if (nums[left] * nums[left] > nums[right] * nums[right]) {
                // 左端平方值更大，放入结果数组
                result[index--] = nums[left] * nums[left];
                left++; // 左指针右移
            } else {
                // 右端平方值更大或相等，放入结果数组
                result[index--] = nums[right] * nums[right];
                right--; // 右指针左移
            }
        }
        return result;
    }
}
```

#### 59. 螺旋矩阵 II

**解题思路**：按照螺旋顺序填充n×n矩阵。定义四个边界（上下左右），按照右→下→左→上的顺序填充，每完成一个方向就收缩对应边界。

```java
class Solution {
    public static int[][] generateMatrix(int n) {
        int[][] result = new int[n][n];
        int count = 1; // 要填入的数字
        
        // 定义四个边界
        int top = 0, bottom = n - 1; // 修复：button改为bottom
        int left = 0, right = n - 1;
        
        while (count <= n * n) {
            // 1. 从左到右填充上边界
            for (int i = left; i <= right; i++) { // 修复：循环条件改为<=
                result[top][i] = count++;
            }
            top++; // 上边界下移
            
            // 2. 从上到下填充右边界
            for (int i = top; i <= bottom; i++) { // 修复：循环条件改为<=
                result[i][right] = count++;
            }
            right--; // 右边界左移
            
            // 3. 从右到左填充下边界（如果还有行需要填充）
            if (top <= bottom) {
                for (int i = right; i >= left; i--) { // 修复：循环条件改为>=
                    result[bottom][i] = count++;
                }
                bottom--; // 下边界上移
            }
            
            // 4. 从下到上填充左边界（如果还有列需要填充）
            if (left <= right) {
                for (int i = bottom; i >= top; i--) { // 修复：循环条件改为>=
                    result[i][left] = count++;
                }
                left++; // 左边界右移
            }
        }
        return result;
    }
}
```

#### 209. 长度最小的子数组

**解题思路**：使用滑动窗口（双指针）技巧。右指针扩展窗口直到和>=target，然后左指针收缩窗口寻找最小长度，重复这个过程。

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int sum = 0; // 当前窗口内元素的和
        int left = 0; // 左指针（窗口左边界）
        int index = 0; // 右指针（窗口右边界）
        int result = Integer.MAX_VALUE; // 记录最小子数组长度

        // 右指针遍历数组，扩展窗口
        while (index < nums.length) {
            sum += nums[index]; // 将当前元素加入窗口
            
            // 当窗口内元素和 >= target时，尝试收缩窗口
            while (sum >= target) {
                int len = index - left + 1; // 当前窗口长度
                result = Math.min(result, len); // 更新最小长度
                sum -= nums[left]; // 移除窗口左边界元素
                left++; // 左指针右移，收缩窗口
            }
            index++; // 右指针右移，扩展窗口
        }
        
        // 如果没找到符合条件的子数组，返回0；否则返回最小长度
        return result == Integer.MAX_VALUE ? 0 : result;
    }
}
```
