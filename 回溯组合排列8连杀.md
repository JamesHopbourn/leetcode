#### 77. 组合

**题目描述**：给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。

**核心思路**：
1. 使用回溯算法，从数字1开始选择
2. 每次选择后递归选择下一个数字，保证递增顺序避免重复
3. 当路径长度等于k时，找到一个有效组合

```java
class Solution {
    List<List<Integer>> result = new LinkedList<>();  // 存储所有组合结果
    LinkedList<Integer> path = new LinkedList<>();     // 当前组合路径

    public List<List<Integer>> combine(int n, int k) {
        dfs(1, n, k);  // 从数字1开始搜索
        return result;
    }

    public void dfs(int startIndex, int n, int k) {
        // 终止条件：当前路径长度等于k
        if (path.size() == k) {
            result.add(new LinkedList<>(path));  // 保存当前组合
            return;
        }
        
        // 遍历候选数字，从startIndex开始保证递增顺序
        for (int i = startIndex; i <= n; i++) {
            path.add(i);          // 选择当前数字
            dfs(i + 1, n, k);     // 递归选择下一个数字
            path.removeLast();    // 回溯，撤销选择
        }
    }
}
```

#### 39. 组合总和

**题目描述**：给定一个无重复元素的正整数数组candidates和一个正整数target，找出candidates中所有可以使数字和为target的唯一组合。数字可以重复使用。

**核心思路**：
1. 数组排序便于剪枝优化
2. 允许重复使用元素，所以递归时传入当前索引i而不是i+1
3. 当sum等于target时找到有效组合
4. 剪枝：当前数字加上sum超过target时直接返回

```java
class Solution {
    List<List<Integer>> result = new LinkedList<>();  // 存储所有组合结果
    LinkedList<Integer> path = new LinkedList<>();     // 当前组合路径

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);  // 排序便于剪枝
        dfs(candidates, target, 0, 0);
        return result;
    }

    public void dfs(int[] candidates, int target, int startIndex, int sum) {
        // 终止条件：当前和等于目标值
        if (sum == target) {
            result.add(new LinkedList<>(path));  // 保存当前组合
            return;
        }
        
        for (int i = startIndex; i < candidates.length; i++) {
            // 剪枝：如果当前数字加上sum超过target，直接返回
            if (sum + candidates[i] > target) {
                return;
            }
            path.add(candidates[i]);                        // 选择当前数字
            dfs(candidates, target, i, sum + candidates[i]); // 递归，允许重复使用当前数字
            path.removeLast();                              // 回溯，撤销选择
        }
    }
}
```

#### 40. 组合总和 II

**题目描述**：给定一个可能包含重复数字的数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。每个数字在每个组合中只能使用一次。

**核心思路**：
1. 数组排序便于去重和剪枝
2. 每个数字只能使用一次，递归时传入i+1
3. 同一层中相同元素只能使用一次（树层去重）
4. 剪枝：当前数字加上sum超过target时直接跳出

```java
class Solution {
    List<List<Integer>> result = new LinkedList<>();  // 存储所有组合结果
    List<Integer> path = new LinkedList<>();           // 当前组合路径

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);  // 排序便于去重和剪枝
        dfs(candidates, target, 0, 0);
        return result;
    }

    public void dfs(int[] candidates, int target, int startIndex, int sum) {
        // 终止条件：当前和等于目标值
        if (sum == target) {
            result.add(new LinkedList<>(path));  // 保存当前组合
            return;
        }
        
        for (int i = startIndex; i < candidates.length; i++) {
            // 剪枝：如果当前数加上sum已经超过target，直接跳出
            if (sum + candidates[i] > target) break;

            // 去重：跳过同一层中的重复元素（树层去重）
            if (i > startIndex && candidates[i] == candidates[i - 1]) continue;
            
            path.add(candidates[i]);                         // 选择当前数字
            dfs(candidates, target, i + 1, sum + candidates[i]); // 递归，每个数字只能用一次
            path.removeLast();                               // 回溯，撤销选择
        }
    }
}
```

#### 216. 组合总和 III

**题目描述**：找出所有相加之和为n的k个数的组合，且满足条件：只使用数字1到9，每个数字最多使用一次。

**核心思路**：
1. 从数字1-9中选择k个不重复的数字
2. 要求这k个数字的和等于target
3. 使用回溯算法，每次选择后递归选择下一个更大的数字
4. 剪枝条件：sum超过target或者path长度超过k

```java
class Solution {
    List<List<Integer>> result = new LinkedList<>();  // 存储所有组合结果
    LinkedList<Integer> path = new LinkedList<>();     // 当前组合路径

    public List<List<Integer>> combinationSum3(int k, int target) {
        dfs(target, k, 1, 0);  // 从数字1开始搜索
        return result;
    }

    public void dfs(int target, int k, int startIndex, int sum) {
        // 终止条件：和等于target且路径长度等于k
        if (sum == target && k == path.size()) {
            result.add(new LinkedList<>(path));  // 保存当前组合
            return;
        }
        
        // 剪枝：sum超过target或路径长度超过k
        if (sum > target || path.size() > k) {
            return;
        }
        
        // 遍历数字1-9，从startIndex开始保证递增顺序
        for (int i = startIndex; i <= 9; i++) {
            path.add(i);                    // 选择当前数字
            dfs(target, k, i + 1, sum + i); // 递归选择下一个数字
            path.removeLast();              // 回溯，撤销选择
        }
    }
}
```

#### 46. 全排列

**题目描述**：给定一个不含重复数字的数组nums，返回其所有可能的全排列。

**核心思路**：
1. 全排列需要考虑所有元素的所有可能顺序
2. 每个位置都可以选择任意未使用的元素
3. 使用used数组或者contains方法避免重复使用元素
4. 当路径长度等于数组长度时，得到一个完整排列

**解法一：使用used数组（推荐，时间复杂度更优）**
```java
class Solution {
    boolean[] used = null;                            // 标记数组，记录元素是否被使用
    List<List<Integer>> result = new LinkedList<>();  // 存储所有排列结果
    LinkedList<Integer> path = new LinkedList<>();     // 当前排列路径

    public List<List<Integer>> permute(int[] nums) {
        used = new boolean[nums.length];  // 初始化标记数组
        dfs(nums);
        return result;
    }

    public void dfs(int[] nums) {
        // 终止条件：路径长度等于数组长度
        if (path.size() == nums.length) {
            result.add(new LinkedList<>(path));  // 保存当前排列
            return;
        }
        
        // 遍历所有元素
        for (int i = 0; i < nums.length; i++) {
            if (used[i]) continue;        // 跳过已使用的元素
            
            used[i] = true;               // 标记为已使用
            path.add(nums[i]);            // 选择当前元素
            dfs(nums);                    // 递归生成剩余位置的排列
            path.removeLast();            // 回溯，撤销选择
            used[i] = false;              // 撤销标记
        }
    }
}
```

**解法二：使用contains方法（简洁但效率较低）**
```java
class Solution {
    List<List<Integer>> result = new LinkedList<>();  // 存储所有排列结果
    List<Integer> path = new LinkedList<>();           // 当前排列路径

    public List<List<Integer>> permute(int[] nums) {
        dfs(nums);
        return result;    
    }
    
    public void dfs(int[] nums) {
        // 终止条件：路径长度等于数组长度
        if (path.size() == nums.length) {
            result.add(new LinkedList<>(path));  // 保存当前排列
            return;
        }
        
        // 遍历所有元素
        for (int i = 0; i < nums.length; i++) {
            if (path.contains(nums[i])) continue;  // 跳过已使用的元素（O(n)时间复杂度）
            
            path.add(nums[i]);            // 选择当前元素
            dfs(nums);                    // 递归生成剩余位置的排列
            path.removeLast();            // 回溯，撤销选择
        }
    }
}
```

#### 47. 全排列 II

**题目描述**：给定一个可包含重复数字的序列nums，按任意顺序返回所有不重复的全排列。

**核心思路**：
1. 先对数组排序，使相同元素相邻
2. 使用used数组标记元素使用状态
3. 树层去重：相同元素在同一层级只能使用一次
4. 关键去重条件：`i > 0 && !used[i-1] && nums[i] == nums[i-1]`

**去重逻辑解析**：
- `!used[i-1]`表示前一个相同元素在当前递归层已经被撤销
- 这确保了相同元素在同一层级按顺序使用，避免重复排列

```java
class Solution {
    boolean[] used = null;                            // 标记数组，记录元素是否被使用
    List<List<Integer>> result = new LinkedList<>();  // 存储所有排列结果
    LinkedList<Integer> path = new LinkedList<>();     // 当前排列路径

    public List<List<Integer>> permuteUnique(int[] nums) {
        used = new boolean[nums.length];  // 初始化标记数组
        Arrays.sort(nums);                // 排序使相同元素相邻
        dfs(nums);
        return result;
    }

    public void dfs(int[] nums) {
        // 终止条件：路径长度等于数组长度
        if (path.size() == nums.length) {
            result.add(new LinkedList<>(path));  // 保存当前排列
            return;
        }
        
        // 遍历所有元素
        for (int i = 0; i < nums.length; i++) {
            // 树层去重：跳过同一层级中的重复元素
            // used[i-1] == false 说明前一个相同元素已在当前层级被撤销
            if (i > 0 && !used[i - 1] && nums[i] == nums[i - 1]) {
                continue;
            }
            
            if (used[i]) continue;        // 跳过已使用的元素
            
            used[i] = true;               // 标记为已使用
            path.add(nums[i]);            // 选择当前元素
            dfs(nums);                    // 递归生成剩余位置的排列
            path.removeLast();            // 回溯，撤销选择
            used[i] = false;              // 撤销标记
        }
    }
}
```

#### 78. 子集

**题目描述**：给你一个整数数组nums，数组中的元素互不相同。返回该数组所有可能的子集（幂集）。

**核心思路**：
1. 子集问题的关键是每个元素都有"选择"和"不选择"两种状态
2. 每到达一个节点都要收集结果（包括空集）
3. 使用startIndex确保子集中元素按原数组顺序，避免重复
4. 不需要终止条件，因为for循环自然结束

```java
class Solution {
    List<List<Integer>> result = new LinkedList<>();  // 存储所有子集结果
    LinkedList<Integer> path = new LinkedList<>();     // 当前子集路径

    public List<List<Integer>> subsets(int[] nums) {
        dfs(0, nums);  // 从索引0开始搜索
        return result;
    }

    public void dfs(int startIndex, int[] nums) {
        // 每到达一个节点都收集当前路径作为一个子集
        result.add(new LinkedList<>(path));
        
        // 遍历剩余元素，每个元素都有选择和不选择两种状态
        for (int i = startIndex; i < nums.length; i++) {
            path.add(nums[i]);      // 选择当前元素
            dfs(i + 1, nums);       // 递归处理剩余元素
            path.removeLast();      // 回溯，撤销选择
        }
    }
}
```

#### 90. 子集 II

**题目描述**：给你一个整数数组nums，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。

**核心思路**：
1. 先对数组排序，使相同元素相邻便于去重
2. 每到达一个节点都收集当前路径作为子集
3. 树层去重：同一层级中相同元素只能使用一次
4. 去重条件：`i > startIndex && nums[i] == nums[i-1]`

**去重逻辑解析**：
- `i > startIndex`确保只在同一层级进行去重判断
- 相同元素在同一层级只使用第一个，跳过后续重复元素

```java
class Solution {
    List<List<Integer>> result = new LinkedList<>();  // 存储所有子集结果
    List<Integer> path = new LinkedList<>();           // 当前子集路径

    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);  // 排序使相同元素相邻
        dfs(0, nums);
        return result;
    }

    public void dfs(int startIndex, int[] nums) {
        // 每到达一个节点都收集当前路径作为一个子集
        result.add(new LinkedList<>(path));
        
        // 遍历剩余元素
        for (int i = startIndex; i < nums.length; i++) {
            // 树层去重：跳过同一层级中的重复元素
            if (i > startIndex && nums[i] == nums[i - 1]) continue;
            
            path.add(nums[i]);      // 选择当前元素
            dfs(i + 1, nums);       // 递归处理剩余元素
            path.removeLast();      // 回溯，撤销选择
        }
    }
}
```

## 回溯算法总结

**回溯三步曲**：
1. **路径**：已经做出的选择
2. **选择列表**：当前可以做的选择
3. **结束条件**：到达决策树底层，无法再做选择的条件

**回溯模板**：
```java
void backtrack(路径, 选择列表) {
    if (满足结束条件) {
        result.add(路径);
        return;
    }
    
    for (选择 in 选择列表) {
        做选择;
        backtrack(路径, 选择列表);
        撤销选择;
    }
}
```

**去重策略**：
- **树层去重**：同一层级相同元素只使用一次（组合问题）
- **树枝去重**：同一路径相同元素只使用一次（排列问题）
