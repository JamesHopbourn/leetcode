# 岛屿问题10连杀 - 循序渐进完全攻略

## 岛屿问题通用模板

岛屿问题是基于二维数组的DFS/BFS遍历问题，核心思想是通过深度/广度优先搜索遍历二维网格。

### DFS模板
```java
public void dfs(int[][] grid, int i, int j) {
    // 边界判断
    if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length) {
        return;
    }
    // 终止条件（如遇到水域或已访问）
    if (grid[i][j] != 1) {
        return;
    }
    
    // 标记已访问
    grid[i][j] = 2; // 或其他标记值
    
    // 向四个方向递归
    dfs(grid, i + 1, j);
    dfs(grid, i - 1, j);
    dfs(grid, i, j + 1);
    dfs(grid, i, j - 1);
}
```

---

## 1. 基础题型

### 200. 岛屿数量 ⭐⭐

**题目描述：** 给定一个由'1'（陆地）和'0'（水）组成的二维网格，计算岛屿的数量。

**算法思路：**
1. 遍历整个网格，遇到'1'时，岛屿数量+1
2. 使用DFS将这个岛屿的所有'1'都置为'0'，避免重复计算
3. 继续遍历，重复上述过程

**时间复杂度：** O(m×n)，每个位置最多访问一次
**空间复杂度：** O(m×n)，递归栈的最大深度

```java
class Solution {
    public int numIslands(char[][] grid) {
        int count = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == '1') {
                    dfs(grid, i, j);
                    count++;
                }
            }
        }
        return count;
    }

    private void dfs(char[][] grid, int i, int j) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] != '1') {
            return;
        }
        
        grid[i][j] = '0'; // 标记为已访问
        dfs(grid, i + 1, j);
        dfs(grid, i - 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i, j - 1);
    }
}
```

**BFS解法：**
```java
class Solution {
    public int numIslands(char[][] grid) {
        int count = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == '1') {
                    bfs(grid, i, j);
                    count++;
                }
            }
        }
        return count;
    }

    private void bfs(char[][] grid, int i, int j) {
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{i, j});
        grid[i][j] = '0';

        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            int x = current[0], y = current[1];

            int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
            for (int[] dir : directions) {
                int nx = x + dir[0], ny = y + dir[1];
                if (nx >= 0 && nx < grid.length && ny >= 0 && ny < grid[0].length && grid[nx][ny] == '1') {
                    grid[nx][ny] = '0';
                    queue.offer(new int[]{nx, ny});
                }
            }
        }
    }
}
```

---

### 695. 岛屿的最大面积 ⭐⭐

**题目描述：** 找到给定二维数组中最大的岛屿面积。

**算法思路：**
1. 遍历网格，遇到陆地时使用DFS计算当前岛屿面积
2. 在DFS过程中累加面积，并将访问过的陆地标记为0
3. 维护全局最大面积

**时间复杂度：** O(m×n)
**空间复杂度：** O(m×n)

```java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int maxArea = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 1) {
                    int area = dfs(grid, i, j);
                    maxArea = Math.max(maxArea, area);
                }
            }
        }
        return maxArea;
    }

    private int dfs(int[][] grid, int i, int j) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] != 1) {
            return 0;
        }
        
        grid[i][j] = 0; // 标记为已访问
        int area = 1;
        area += dfs(grid, i + 1, j);
        area += dfs(grid, i - 1, j);
        area += dfs(grid, i, j + 1);
        area += dfs(grid, i, j - 1);
        return area;
    }
}
```

---

### 463. 岛屿的周长 ⭐⭐

**题目描述：** 计算岛屿的周长（假设只有一个岛屿）。

**算法思路：**
1. 找到岛屿后使用DFS遍历
2. 每遇到边界或水域，周长+1
3. 使用临时标记避免重复访问

**时间复杂度：** O(m×n)
**空间复杂度：** O(m×n)

```java
class Solution {
    public int islandPerimeter(int[][] grid) {
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 1) {
                    return dfs(grid, i, j);
                }
            }
        }
        return 0;
    }

    private int dfs(int[][] grid, int i, int j) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) {
            return 1; // 遇到边界或水域，周长+1
        }
        if (grid[i][j] != 1) {
            return 0; // 已访问过
        }
        
        grid[i][j] = 2; // 标记为已访问
        int perimeter = 0;
        perimeter += dfs(grid, i + 1, j);
        perimeter += dfs(grid, i - 1, j);
        perimeter += dfs(grid, i, j + 1);
        perimeter += dfs(grid, i, j - 1);
        return perimeter;
    }
}
```

---

## 2. 进阶题型

### 1254. 统计封闭岛屿的数目 ⭐⭐⭐

**题目描述：** 统计完全被水包围的岛屿数量（不与边界相连）。

**算法思路：**
1. 先将所有边界相连的岛屿"淹没"（DFS将其变为水域）
2. 再统计剩余的岛屿数量

**时间复杂度：** O(m×n)
**空间复杂度：** O(m×n)

```java
class Solution {
    public int closedIsland(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        
        // 淹没边界相连的岛屿
        for (int j = 0; j < n; j++) {
            dfs(grid, 0, j);     // 上边界
            dfs(grid, m - 1, j); // 下边界
        }
        for (int i = 0; i < m; i++) {
            dfs(grid, i, 0);     // 左边界
            dfs(grid, i, n - 1); // 右边界
        }
        
        // 统计封闭岛屿
        int count = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    count++;
                    dfs(grid, i, j);
                }
            }
        }
        return count;
    }

    private void dfs(int[][] grid, int i, int j) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 1) {
            return;
        }
        
        grid[i][j] = 1; // 将陆地变成水域
        dfs(grid, i + 1, j);
        dfs(grid, i - 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i, j - 1);
    }
}
```

---

### 1020. 飞地的数量 ⭐⭐⭐

**题目描述：** 统计无法从边界走出的陆地单元格数量。

**算法思路：**
1. 从边界开始DFS，将所有连通的陆地标记为已访问
2. 统计剩余未访问的陆地数量

**时间复杂度：** O(m×n)
**空间复杂度：** O(m×n)

```java
class Solution {
    public int numEnclaves(int[][] grid) {
        int m = grid.length, n = grid[0].length;

        // 从边界开始淹没连通的陆地
        for (int i = 0; i < m; i++) {
            dfs(grid, i, 0);     // 左边界
            dfs(grid, i, n - 1); // 右边界
        }
        for (int j = 0; j < n; j++) {
            dfs(grid, 0, j);     // 上边界
            dfs(grid, m - 1, j); // 下边界
        }

        // 统计剩余陆地
        int count = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    count++;
                }
            }
        }
        return count;
    }

    private void dfs(int[][] grid, int i, int j) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) {
            return;
        }
        
        grid[i][j] = 0;
        dfs(grid, i + 1, j);
        dfs(grid, i - 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i, j - 1);
    }
}
```

---

### 130. 被围绕的区域 ⭐⭐⭐

**题目描述：** 将所有被'X'完全包围的'O'替换为'X'。

**算法思路：**
1. 从边界的'O'开始DFS，将连通的'O'标记为临时字符'#'
2. 遍历整个数组：剩余的'O'变为'X'，'#'变回'O'

**时间复杂度：** O(m×n)
**空间复杂度：** O(m×n)

```java
class Solution {
    public void solve(char[][] board) {
        int m = board.length, n = board[0].length;
        
        // 从边界开始标记不被围绕的'O'
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                boolean isEdge = i == 0 || j == 0 || i == m - 1 || j == n - 1;
                if (isEdge && board[i][j] == 'O') {
                    dfs(board, i, j);
                }
            }
        }
        
        // 后处理：'O'变'X'，'#'变'O'
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == 'O') board[i][j] = 'X';
                if (board[i][j] == '#') board[i][j] = 'O';
            }
        }
    }

    private void dfs(char[][] board, int i, int j) {
        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || 
            board[i][j] == '#' || board[i][j] == 'X') {
            return;
        }
        
        board[i][j] = '#';
        dfs(board, i + 1, j);
        dfs(board, i - 1, j);
        dfs(board, i, j + 1);
        dfs(board, i, j - 1);
    }
}
```

---

## 3. 高级题型

### 1905. 统计子岛屿 ⭐⭐⭐⭐

**题目描述：** grid2中的岛屿是grid1的子岛屿，当且仅当grid2中岛屿的每个陆地单元格在grid1中也是陆地。

**算法思路：**
1. 遍历grid2中的每个岛屿
2. 在DFS过程中检查对应位置在grid1中是否也是陆地
3. 使用标志位记录当前岛屿是否为子岛屿

**时间复杂度：** O(m×n)
**空间复杂度：** O(m×n)

```java
class Solution {
    private boolean isSubIsland;

    public int countSubIslands(int[][] grid1, int[][] grid2) {
        int count = 0;
        for (int i = 0; i < grid2.length; i++) {
            for (int j = 0; j < grid2[0].length; j++) {
                if (grid2[i][j] == 1) {
                    isSubIsland = true;
                    dfs(grid1, grid2, i, j);
                    if (isSubIsland) {
                        count++;
                    }
                }
            }
        }
        return count;
    }

    private void dfs(int[][] grid1, int[][] grid2, int i, int j) {
        if (i < 0 || i >= grid2.length || j < 0 || j >= grid2[0].length || grid2[i][j] == 0) {
            return;
        }

        if (grid1[i][j] == 0) {
            isSubIsland = false; // 不是子岛屿
        }

        grid2[i][j] = 0; // 标记为已访问
        dfs(grid1, grid2, i + 1, j);
        dfs(grid1, grid2, i - 1, j);
        dfs(grid1, grid2, i, j + 1);
        dfs(grid1, grid2, i, j - 1);
    }
}
```

---

### 694. 不同岛屿的数量 ⭐⭐⭐⭐

**题目描述：** 统计形状不同的岛屿数量（相同形状但位置不同的岛屿算作一种）。

**算法思路：**
1. 用字符串记录岛屿的形状（相对路径）
2. 使用Set去重，统计不同形状的数量
3. DFS时记录移动方向（上下左右用不同字符表示）

**时间复杂度：** O(m×n)
**空间复杂度：** O(m×n)

```java
class Solution {
    public int numDistinctIslands(int[][] grid) {
        Set<String> islands = new HashSet<>();
        
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 1) {
                    StringBuilder path = new StringBuilder();
                    dfs(grid, i, j, path, 'S'); // S for start
                    islands.add(path.toString());
                }
            }
        }
        return islands.size();
    }

    private void dfs(int[][] grid, int i, int j, StringBuilder path, char direction) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) {
            return;
        }
        
        grid[i][j] = 0;
        path.append(direction);
        
        dfs(grid, i + 1, j, path, 'D'); // Down
        dfs(grid, i - 1, j, path, 'U'); // Up
        dfs(grid, i, j + 1, path, 'R'); // Right
        dfs(grid, i, j - 1, path, 'L'); // Left
        
        path.append('B'); // Back (回溯标记)
    }
}
```

---

### 79. 单词搜索 ⭐⭐⭐

**题目描述：** 在二维字符网格中搜索单词。

**算法思路：**
1. 遍历网格，找到单词首字母作为起点
2. 使用DFS + 回溯搜索路径
3. 临时标记访问过的位置，回溯时恢复

**时间复杂度：** O(m×n×4^L)，L为单词长度
**空间复杂度：** O(L)

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (board[i][j] == word.charAt(0)) {
                    if (dfs(board, i, j, word, 0)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    private boolean dfs(char[][] board, int i, int j, String word, int index) {
        if (index == word.length()) return true;

        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || 
            board[i][j] != word.charAt(index)) {
            return false;
        }

        char temp = board[i][j];
        board[i][j] = '#'; // 临时标记

        boolean found = dfs(board, i + 1, j, word, index + 1) ||
                       dfs(board, i - 1, j, word, index + 1) ||
                       dfs(board, i, j + 1, word, index + 1) ||
                       dfs(board, i, j - 1, word, index + 1);

        board[i][j] = temp; // 回溯恢复
        return found;
    }
}
```

---

## 4. BFS专题

### 994. 腐烂的橘子 ⭐⭐⭐

**题目描述：** 计算所有新鲜橘子腐烂所需的最短时间。

**算法思路：**
1. 使用BFS模拟腐烂过程（多源BFS）
2. 将所有初始腐烂的橘子入队作为起点
3. 逐层扩散，记录时间

**时间复杂度：** O(m×n)
**空间复杂度：** O(m×n)

```java
class Solution {
    public int orangesRotting(int[][] grid) {
        Queue<int[]> queue = new LinkedList<>();
        int fresh = 0;

        // 统计新鲜橘子并将腐烂橘子入队
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == 1) {
                    fresh++;
                } else if (grid[i][j] == 2) {
                    queue.offer(new int[]{i, j});
                }
            }
        }

        int time = 0;
        int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

        while (!queue.isEmpty() && fresh > 0) {
            time++;
            int size = queue.size();
            
            // 处理当前层的所有腐烂橘子
            for (int i = 0; i < size; i++) {
                int[] current = queue.poll();
                
                for (int[] dir : directions) {
                    int newRow = current[0] + dir[0];
                    int newCol = current[1] + dir[1];
                    
                    if (newRow >= 0 && newRow < grid.length && 
                        newCol >= 0 && newCol < grid[0].length && 
                        grid[newRow][newCol] == 1) {
                        
                        grid[newRow][newCol] = 2;
                        queue.offer(new int[]{newRow, newCol});
                        fresh--;
                    }
                }
            }
        }
        return fresh == 0 ? time : -1;
    }
}
```

---

## 5. 困难题型

### 1568. 使陆地分离的最少天数 ⭐⭐⭐⭐⭐

**题目描述：** 计算使岛屿分离成两个或更多岛屿所需的最少天数。

**算法思路：**
1. 特殊情况：如果已经不连通或只有0-1个陆地，返回对应值
2. 尝试移除每个陆地，检查是否能分离岛屿（答案只能是0, 1, 2）
3. 最坏情况下答案是2（移除岛屿的关键连接点）

**时间复杂度：** O((m×n)²)
**空间复杂度：** O(m×n)

```java
class Solution {
    public int minDaysToDisconnect(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        
        // 检查当前连通性
        if (countIslands(grid) != 1) return 0;
        
        // 尝试移除每个陆地
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    grid[i][j] = 0;
                    if (countIslands(grid) != 1) {
                        return 1;
                    }
                    grid[i][j] = 1; // 恢复
                }
            }
        }
        
        return 2; // 最坏情况
    }
    
    private int countIslands(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        boolean[][] visited = new boolean[m][n];
        int count = 0;
        
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1 && !visited[i][j]) {
                    count++;
                    dfs(grid, visited, i, j);
                }
            }
        }
        return count;
    }
    
    private void dfs(int[][] grid, boolean[][] visited, int i, int j) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || 
            visited[i][j] || grid[i][j] == 0) {
            return;
        }
        
        visited[i][j] = true;
        dfs(grid, visited, i + 1, j);
        dfs(grid, visited, i - 1, j);
        dfs(grid, visited, i, j + 1);
        dfs(grid, visited, i, j - 1);
    }
}
```

---

## 6. 额外经典题目

### 417. 太平洋大西洋水流问题 ⭐⭐⭐⭐

**题目描述：** 找出雨水既能流向太平洋又能流向大西洋的陆地单元。

**算法思路：**
1. 分别从太平洋边界和大西洋边界开始逆向DFS
2. 找出两个海洋都能到达的位置
3. 逆向思维：从海洋向高处流

**时间复杂度：** O(m×n)
**空间复杂度：** O(m×n)

```java
class Solution {
    public List<List<Integer>> pacificAtlantic(int[][] heights) {
        int m = heights.length, n = heights[0].length;
        boolean[][] pacific = new boolean[m][n];
        boolean[][] atlantic = new boolean[m][n];
        
        // 从边界开始DFS
        for (int i = 0; i < m; i++) {
            dfs(heights, pacific, i, 0, heights[i][0]);        // 太平洋左边界
            dfs(heights, atlantic, i, n - 1, heights[i][n - 1]); // 大西洋右边界
        }
        for (int j = 0; j < n; j++) {
            dfs(heights, pacific, 0, j, heights[0][j]);        // 太平洋上边界
            dfs(heights, atlantic, m - 1, j, heights[m - 1][j]); // 大西洋下边界
        }
        
        // 找交集
        List<List<Integer>> result = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (pacific[i][j] && atlantic[i][j]) {
                    result.add(Arrays.asList(i, j));
                }
            }
        }
        return result;
    }
    
    private void dfs(int[][] heights, boolean[][] visited, int i, int j, int prevHeight) {
        if (i < 0 || i >= heights.length || j < 0 || j >= heights[0].length || 
            visited[i][j] || heights[i][j] < prevHeight) {
            return;
        }
        
        visited[i][j] = true;
        dfs(heights, visited, i + 1, j, heights[i][j]);
        dfs(heights, visited, i - 1, j, heights[i][j]);
        dfs(heights, visited, i, j + 1, heights[i][j]);
        dfs(heights, visited, i, j - 1, heights[i][j]);
    }
}
```

---

### 827. 最大人工岛 ⭐⭐⭐⭐⭐

**题目描述：** 最多可以将一个0变成1，求最大的岛屿面积。

**算法思路：**
1. 给每个岛屿编号，记录每个岛屿的面积
2. 遍历每个0，计算变成1后能连接的岛屿总面积
3. 注意去重（同一个岛屿不能重复计算）

**时间复杂度：** O(m×n)
**空间复杂度：** O(m×n)

```java
class Solution {
    public int largestIsland(int[][] grid) {
        int n = grid.length;
        Map<Integer, Integer> areaMap = new HashMap<>();
        int islandId = 2;
        int maxArea = 0;
        
        // 第一步：给每个岛屿编号并记录面积
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    int area = dfs(grid, i, j, islandId);
                    areaMap.put(islandId, area);
                    maxArea = Math.max(maxArea, area);
                    islandId++;
                }
            }
        }
        
        // 第二步：尝试填海造陆
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    Set<Integer> neighbors = new HashSet<>();
                    int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
                    
                    for (int[] dir : directions) {
                        int ni = i + dir[0], nj = j + dir[1];
                        if (ni >= 0 && ni < n && nj >= 0 && nj < n && grid[ni][nj] > 1) {
                            neighbors.add(grid[ni][nj]);
                        }
                    }
                    
                    int newArea = 1;
                    for (int id : neighbors) {
                        newArea += areaMap.get(id);
                    }
                    maxArea = Math.max(maxArea, newArea);
                }
            }
        }
        
        return maxArea;
    }
    
    private int dfs(int[][] grid, int i, int j, int islandId) {
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] != 1) {
            return 0;
        }
        
        grid[i][j] = islandId;
        int area = 1;
        area += dfs(grid, i + 1, j, islandId);
        area += dfs(grid, i - 1, j, islandId);
        area += dfs(grid, i, j + 1, islandId);
        area += dfs(grid, i, j - 1, islandId);
        return area;
    }
}
```

---

## 总结与套路

### 解题套路总结

1. **基础岛屿问题**：直接DFS/BFS遍历，标记访问过的陆地
2. **边界相关题目**：先处理边界，再处理内部
3. **子岛屿/形状题目**：在DFS过程中维护额外信息
4. **最短路径题目**：使用BFS层序遍历
5. **连通性问题**：多次DFS检查连通分量数目

### 常用技巧

- **原地修改**：直接在原数组上标记访问状态，节省空间
- **多源BFS**：同时从多个起点开始BFS
- **逆向思维**：从边界开始向内部搜索
- **回溯标记**：临时标记 + 恢复，适用于需要多次尝试的场景

### 时空复杂度规律

- **时间复杂度**：通常是O(m×n)，每个位置最多访问常数次
- **空间复杂度**：递归栈深度最坏为O(m×n)，BFS队列也是O(m×n)

这套题目从易到难，涵盖了岛屿问题的各种类型和解题技巧。掌握这些题目后，面对类似的网格搜索问题就能游刃有余了！