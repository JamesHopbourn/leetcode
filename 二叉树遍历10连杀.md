# 二叉树遍历10连杀

本教程通过10道经典题目，循序渐进掌握二叉树遍历的核心技巧。从基础的DFS三种遍历方式，到BFS层序遍历，再到各种变形题，帮你一网打尽二叉树遍历问题。

**学习路径：基础遍历 → 层序遍历 → 高级变形**

## 核心知识点

### 1. 遍历方式分类
- **深度优先搜索(DFS)**: 前序、中序、后序遍历
- **广度优先搜索(BFS)**: 层序遍历

### 2. 实现方法对比
- **递归实现**: 代码简洁，思路清晰，但可能栈溢出
- **迭代实现**: 使用栈/队列模拟递归过程，空间可控

### 3. 遍历顺序记忆
- **前序遍历**: 根→左→右 (根节点最先访问)
- **中序遍历**: 左→根→右 (根节点在中间访问)  
- **后序遍历**: 左→右→根 (根节点最后访问)
- **层序遍历**: 逐层从左到右访问

## 1. 前序遍历基础篇

#### 144. 二叉树的前序遍历

**解题思路：**
前序遍历的访问顺序是"根→左→右"，即先访问根节点，再递归遍历左子树，最后递归遍历右子树。

**方法一：递归实现（推荐）**
- 时间复杂度：O(n)，每个节点访问一次
- 空间复杂度：O(h)，h为树的高度，最坏情况O(n)
```java
class Solution {
    List<Integer> result = new LinkedList<>();
    public List<Integer> preorderTraversal(TreeNode root) {
        dfs(root);
        return result;
    }

    public void dfs(TreeNode root) {
        if (root != null) {
            result.add(root.val);
            dfs(root.left);
            dfs(root.right);
        }
    }
}
```

**方法二：递归实现（另一种写法）**
```java
class Solution {
    List<Integer> result = new LinkedList<>();
    public List<Integer> preorderTraversal(TreeNode root) {
        if (root == null) {
            return result;
        }
        result.add(root.val);  // 先访问根节点
        preorderTraversal(root.left);   // 再递归左子树
        preorderTraversal(root.right);  // 最后递归右子树
        return result;
    }
}
```

**方法三：迭代实现（栈模拟）**
- 时间复杂度：O(n)
- 空间复杂度：O(h)

**关键技巧：** 栈的先进后出特性，需要先压入右子树，再压入左子树

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new LinkedList<>();
        if (root == null) {
            return result;  // 边界条件判断
        }
        
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        
        while (!stack.isEmpty()) {
            TreeNode node = stack.pop();
            result.add(node.val);  // 访问当前节点
            
            // 关键：先压右子树，再压左子树（栈的后进先出特性）
            if (node.right != null) {
                stack.push(node.right);
            }
            if (node.left != null) {
                stack.push(node.left);
            }
        }
        return result;
    }
}
```

**💡 易错点提醒：**
1. 栈压入顺序：必须先压右子树，再压左子树
2. 空树判断：需要在开始时判断root是否为null

## 2. 后序遍历基础篇

#### 145. 二叉树的后序遍历

**解题思路：**
后序遍历的访问顺序是"左→右→根"，即先递归遍历左子树，再递归遍历右子树，最后访问根节点。

**方法一：递归实现**
- 时间复杂度：O(n)
- 空间复杂度：O(h)
```java
class Solution {
    List<Integer> result = new LinkedList<>();
    public void dfs(TreeNode root){
        if (root != null){
            dfs(root.left);
            dfs(root.right);
            result.add(root.val);
        }
    }

    public List<Integer> postorderTraversal(TreeNode root) {
        dfs(root);
        return result;
    }
}
```

**方法二：递归实现（另一种写法）**
```java
class Solution {
    List<Integer> result = new LinkedList<>();
    public List<Integer> postorderTraversal(TreeNode root) {
        if (root == null) {
            return result;
        }
        postorderTraversal(root.left);   // 先递归左子树
        postorderTraversal(root.right);  // 再递归右子树
        result.add(root.val);            // 最后访问根节点
        return result;
    }
}
```

**方法三：迭代实现（巧妙方法）**
- 时间复杂度：O(n)
- 空间复杂度：O(h)

**核心技巧：** 利用前序遍历的变形来实现后序遍历
- 前序遍历：根→左→右
- 调整为：根→右→左，然后逆序得到：左→右→根

```java
public class Solution {
    List<Integer> list = new LinkedList<>();
    public List<Integer> postorderTraversal(TreeNode root) {
        if (root == null) return list;
        
        Deque<TreeNode> deque = new LinkedList<>();
        deque.addFirst(root);

        while (!deque.isEmpty()) {
            TreeNode node = deque.removeFirst();
            // 关键：头插法实现逆序（根右左 → 左右根）
            list.addFirst(node.val);

            // 注意：这里先压左子树，再压右子树（与前序相反）
            if (node.left != null) {
                deque.addFirst(node.left);
            }
            if (node.right != null) {
                deque.addFirst(node.right);
            }
        }
        return list;
    }
}
```

**💡 解题技巧：**
1. 后序遍历的迭代实现较复杂，可以利用前序遍历变形
2. 调整压栈顺序 + 头插法 = 后序遍历结果


## 3. 中序遍历基础篇

#### 94. 二叉树的中序遍历

**解题思路：**
中序遍历的访问顺序是"左→根→右"，对于二叉搜索树，中序遍历结果是有序的。

**方法一：递归实现**
- 时间复杂度：O(n)
- 空间复杂度：O(h)
```java
class Solution {
    List<Integer> result = new LinkedList<>();
    public void dfs(TreeNode root) {
        if (root != null) {
            dfs(root.left);
            result.add(root.val);
            dfs(root.right);
        }
    }

    public List<Integer> inorderTraversal(TreeNode root) {
        dfs(root);
        return result;
    }
}
```

**方法二：递归实现（另一种写法）**
```java
class Solution {
    List<Integer> result = new LinkedList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        if (root == null) {
          return result;
        }
        inorderTraversal(root.left);  // 先递归左子树
        result.add(root.val);         // 再访问根节点
        inorderTraversal(root.right); // 最后递归右子树
        return result;
    }
}
```

**方法三：迭代实现（栈模拟）**
- 时间复杂度：O(n)
- 空间复杂度：O(h)

**核心思想：** 用栈模拟递归过程，先遍历到最左节点，然后处理节点并转向右子树

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new LinkedList<>();
        if (root == null) {
            return result;
        }
        
        Stack<TreeNode> stack = new Stack<>();
        TreeNode curr = root;
        
        while (curr != null || !stack.isEmpty()) {
            // 步骤1：一直走到最左边，将路径上的节点入栈
            while (curr != null) {
                stack.push(curr);
                curr = curr.left;
            }
            
            // 步骤2：弹出栈顶节点并访问
            curr = stack.pop();
            result.add(curr.val);
            
            // 步骤3：转向右子树
            curr = curr.right;
        }
        return result;
    }
}
```

**💡 中序遍历特点：**
1. 对于二叉搜索树，中序遍历结果是升序排列的
2. 迭代实现需要用栈保存路径，比前序和后序复杂一些

## 4. 层序遍历基础篇

#### 102. 二叉树的层序遍历

**解题思路：**
层序遍历使用BFS（广度优先搜索），逐层从左到右访问节点。关键是用队列保存每一层的节点，并记录当前层的节点数量。

**实现方法：队列 + 层次标记**
- 时间复杂度：O(n)，每个节点访问一次
- 空间复杂度：O(w)，w为树的最大宽度
```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new LinkedList<>();
        if (root == null) {
            return result;
        }
        
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);

        while (!queue.isEmpty()) {
            int size = queue.size();  // 关键：记录当前层的节点数量
            List<Integer> level = new LinkedList<>();
            
            // 处理当前层的所有节点
            while (size-- > 0) {
                TreeNode node = queue.poll();
                level.add(node.val);  // 访问当前节点
                
                // 将下一层的节点加入队列
                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.add(node.right);
                }
            }
            result.add(level);
        }
        return result;
    }
}
```

**💡 核心技巧：**
1. 在进入内层循环前记录队列大小，确保只处理当前层的节点
2. 队列的FIFO特性保证了从左到右的访问顺序

## 5. 层序遍历变形篇

#### 107. 二叉树的层序遍历 II

**解题思路：**
自底向上的层序遍历，只需在正常层序遍历基础上将结果反转。

**实现方法：层序遍历 + 结果反转**
- 时间复杂度：O(n)
- 空间复杂度：O(w)
```java
class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> result = new LinkedList<>();
        if (root == null) {
            return result;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);

        while (!queue.isEmpty()){
            int size = queue.size();
            List<Integer> level = new LinkedList<>();
            while(size-->0){
                TreeNode node = queue.poll();
                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.add(node.right);
                }
                level.add(node.val);
            }
            result.add(level);
        }
        
        // 关键：将结果反转，实现自底向上
        Collections.reverse(result);
        return result;
    }
}
```

#### 103. 二叉树的锯齿形层序遍历

**解题思路：**
锯齿形遍历即奇数层从左到右，偶数层从右到左。可以通过控制插入位置或使用双端队列实现。

**实现方法：层序遍历 + 方向控制**
- 时间复杂度：O(n)
- 空间复杂度：O(w)
```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> result = new LinkedList<>();
        if (root == null) {
            return result;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        boolean leftToRight = true;
        
        while (!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> list = new LinkedList<>();
            
            while (size-->0) {
                TreeNode node = queue.poll();
                // 关键：根据方向决定插入位置
                if (leftToRight) {
                    list.add(node.val);      // 尾插：从左到右
                } else {
                    list.add(0, node.val);   // 头插：从右到左
                }
                
                if (node.left != null) queue.add(node.left);
                if (node.right != null) queue.add(node.right);
            }
            result.add(list);
            leftToRight = !leftToRight;  // 每层切换方向
        }
        return result;
    }
}
```

#### 199. 二叉树的右视图

**解题思路：**
右视图就是每一层最右边的节点。可以在层序遍历过程中，记录每层的最后一个节点。

**实现方法：层序遍历 + 最后节点标记**
- 时间复杂度：O(n)
- 空间复杂度：O(w)
```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new LinkedList<>();
        if (root == null) {
            return result;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            while (size-->0) {
                TreeNode node = queue.poll();
                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.add(node.right);
                }
                // 关键：当size为0时，说明这是当前层的最后一个节点
                if (size == 0) {
                    result.add(node.val);
                }
            }
        }
        return result;
    }
}

```

## 6. 高级应用篇

#### 297. 二叉树的序列化与反序列化

**解题思路：**
序列化使用层序遍历，将树转换为字符串；反序列化则根据字符串重建树结构。空节点用"null"表示。

**实现方法：层序遍历 + 字符串操作**
- 时间复杂度：O(n)
- 空间复杂度：O(n)
```java
public class Codec {
    public String serialize(TreeNode root) {
        if (root == null) return "[]";
        StringBuilder sb = new StringBuilder("[");
        Queue<TreeNode> queue = new LinkedList<>(){};
        queue.add(root);

        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if (node != null) {
                sb.append(node.val + ",");  // 记录节点值
                queue.add(node.left);        // 左子节点入队（可能为null）
                queue.add(node.right);       // 右子节点入队（可能为null）
            } else {
                sb.append("null,");          // 空节点用"null"表示
            }
        }
        return sb.deleteCharAt(sb.length() - 1).append("]").toString();
    }

    public TreeNode deserialize(String data) {
        if (data.equals("[]")) return null;
        String[] vals = data.substring(1, data.length() - 1).split(",");
        TreeNode root = new TreeNode(Integer.parseInt(vals[0]));  // 创建根节点
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        int i = 1;  // 从第二个元素开始
        
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            
            // 处理左子节点
            if (!vals[i].equals("null")) {
                node.left = new TreeNode(Integer.parseInt(vals[i]));
                queue.add(node.left);
            }
            i++;
            
            // 处理右子节点
            if (!vals[i].equals("null")) {
                node.right = new TreeNode(Integer.parseInt(vals[i]));
                queue.add(node.right);
            }
            i++;
        }
        return root;
    }
}
```

#### 314. 二叉树垂直遍历

**解题思路：**
垂直遍历需要按列坐标对节点进行分组。使用层序遍历 + 列坐标跟踪，左子节点列坐标-1，右子节点列坐标+1。

**实现方法：层序遍历 + 哈希表 + 列坐标**
- 时间复杂度：O(n)
- 空间复杂度：O(n)
```java
class Solution {
    public List<List<Integer>> verticalOrder(TreeNode root) {
        List<List<Integer>> result = new LinkedList<>();
        if (root == null) {
            return result;
        }
        
        Map<Integer, List<Integer>> map = new HashMap<>();
        Queue<TreeNode> queue = new LinkedList<>();
        Queue<Integer> cols = new LinkedList<>();  // 关键：记录每个节点的列坐标
        
        queue.add(root);
        cols.add(0);
        int minCol = 0, maxCol = 0;
        
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            int col = cols.poll();
            
            if (!map.containsKey(col)) {
                map.put(col, new LinkedList<>());
            }
            map.get(col).add(node.val);
            
            // 左子节点列坐标 = 父节点列坐标 - 1
            if (node.left != null) {
                queue.add(node.left);
                cols.add(col - 1);
                minCol = Math.min(minCol, col - 1);
            }
            // 右子节点列坐标 = 父节点列坐标 + 1
            if (node.right != null) {
                queue.add(node.right);
                cols.add(col + 1);
                maxCol = Math.max(maxCol, col + 1);
            }
        }
        
        // 按列坐标从左到右输出结果
        for (int i = minCol; i <= maxCol; i++) {
            result.add(map.get(i));
        }
        return result;
    }
}

**💡 垂直遍历关键点：**
1. 使用两个队列分别保存节点和对应的列坐标
2. 用哈希表按列坐标分组存储节点值
3. 记录最小和最大列坐标，确保输出顺序正确

---

## 📚 学习总结

### 🎯 核心技巧回顾

1. **遍历方式选择**
   - DFS适合需要探索到叶子节点的问题
   - BFS适合按层处理的问题

2. **实现方式对比**
   - 递归：代码简洁，但可能栈溢出
   - 迭代：空间可控，但实现复杂

3. **常用数据结构**
   - 栈：用于DFS迭代实现
   - 队列：用于BFS层序遍历
   - 哈希表：用于复杂条件的分组

### 🚀 进阶练习建议

1. **熟练掌握基础三种DFS遍历的递归和迭代实现**
2. **深入理解层序遍历的层次控制技巧**
3. **尝试更多变形题，如Morris遍历、线索二叉树等**
4. **结合具体应用场景，如表达式解析、文件系统遍历等**

### ⚠️ 常见易错点

1. **边界条件处理**：空树判断不能遗漏
2. **栈/队列操作顺序**：注意数据结构的特性
3. **层序遍历的层次标记**：必须在内循环前记录队列大小
4. **空间复杂度优化**：合理选择递归vs迭代

通过这10道题的系统学习，你已经掌握了二叉树遍历的核心技能。继续练习更多变形题，不断提升代码实现的熟练度！
```
